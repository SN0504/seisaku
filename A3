第一案
折り紙の折り目は
1回目         0
2回目    0    0    1
3回目   001   0   011
4回目 0010011 0 0011011
のように中央の0を軸として左側にn-1の時の折り目、右側にn-1の時の折り目の中央を1にしたものを加えたものになる。
-----------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <math.h>
#include <string.h>
 
int main(void) {
    //数値より文字列として扱ったほうが結合しやすいためint型ではなくchar型を使用する
    //最大の折り目数は多くなるので格納できるだけのメモリを確保しておく
    char str1[1500000]; //左側で使用するn-1となる折り目の保存場所
    char str2[1500000]; //右側で使用するn-1となる折り目の中央を1にするための保存場所
    char str3[1500000]; //両方の折り目を合わせる保存場所
    char c = '0';
    int n,i,p1,p2;
    scanf("%d",&n);
    for(i = 0;i < n;i++){
        if(i == 0){
            str1[0] = '0'; //一回目は最初の0を入れる
        } else {
            p1 = pow(2,i); //2回目の折り目は3つ、3回目の折り目は7つ、4回目の折り目は15個であるため、折り目の数はn^2-1で求めることができるため
                             右側で使用する部分をコピーするときに何文字目までをコピーするかを把握しておくことで無駄を省く（必要があるかはわからない）
            strncpy(str2,str1,p1 * 2); //n-1の折り目をstr2に入れる
            p2 = p1 / 2;
            str2[p2 - 1] = '1'; //折り目の中央を1に書き換える
            sprintf(str3,"%s%c%s",str1,c,str2); //str3にn-1の折り目、0、n-1の折り目の中央を1にしたものを記憶させる
            strncpy(str1,str3,p1 * 2); //str1をstr3に書き換える
        }
    }
    printf("%s",str1);
    return 0;
}
-----------------------------------------------------------------------------------------------------
問題なくクリア
