第一案
左上から順番に島をチェックしていき、1の島を見つけた場合その島の上下左右に1の島があるかを探す。もし、1の島があるのであればそれを2、3、4の島にしていき
またその島の上下左右に1の島があるかを探す。これを再帰により繰り返すことでひとつのまとまった1の島を全て同じ数字にそろえることができる。
---------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>

// 自作関数内で使用する変数は先に宣言しておく
int row,col,num;
int map[1000][1000]; //上限1000×1000のマップを作成する

// マッピング用の関数。その時点での縦横それぞれの座標を持ってくる。返り値はないためvoid形で作成しても大丈夫です
void mapping(int row,int col);

int main(void){
    int n,m,i,j;
    //地図の要素の個数の入力
    scanf("%d %d",&n,&m);
    //地図の海と島をマップ配列に投入
    for(i = 0;i < m;i++) {
        for(j = 0;j < n;j++) {
            scanf("%d",&map[i][j]);
        }
    }
    //上書き用島ナンバーの設定
    num = 2;
    //島ナンバーが1の島を探す
    for(i = 0;i < m;i++) {
        for(j = 0;j < n;j++) {
            if(map[i][j] == 1) {
                mapping(i,j); //もし島ナンバーが1の島があった場合その座標をもとにマッピング関数を呼び出す
                num++;
            }
        }
    }
    printf("%d",num - 2);
    //デバッグ用（マップの中身）
    /*for(i = 0;i < m;i++) {
        for(j = 0;j < n;j++) {
            printf("%2d ",map[i][j]);
        }
        printf("\n");
    }*/
    return 0;
}
//再帰を利用して隣り合っている島の数値を変更する
void mapping(int row,int col) {
    int i,j;
    map[row][col] = num;　//先に数値を変更しておかないと隣り合った座標と永久ループになってしまうため、ここで変更しておく
    for(i = -1;i <= 1;i++) {
        for(j = -1;j <= 1;j++) {
            if(i == 0 || j == 0){ //iかjを0で固定することで斜めの座標を参照することを防ぐ
                if(map[row + i][col + j] == 1) { //今の座標の島と隣り合った島を比較している
                    mapping(row + i,col + j); //隣あっている島の座標をもとにマッピング関数を呼び出すことにより再帰処理をする
                }
            }
        }
    }
}
---------------------------------------------------------------------------------------------------------------------------------------
なぜかランタイムエラーが発生してしまうため再修正

第二案
マッピング関数を呼び出す際に現在の島のiかjの座標が0の時にmap[5][-1]のようにありもしない配列を参照してしまうためにエラーが出たものだと考えた
-----------------------------------------------------
#include <stdio.h>

int row,col,num;
int map[1002][1002];

void mapping(int row,int col);

int main(void){
    int n,m,i,j;
    //地図の要素の個数の入力
    scanf("%d %d",&n,&m);
    //地図の海と島をマップ配列に投入。この時外周のi=0,j=0,i=1001,j=1001の座標を空けておく
    for(i = 1;i < m + 1;i++) {
        for(j = 1;j < n + 1;j++) {
            scanf("%d",&map[i][j]);
        }
    }
    for(i = 1;i <= n + 1;i++){
        map[i][0] = 0;
        map[i][n + 1] = 0;
    }
    for(j = 1;j <= m + 1;j++){
        map[0][j] = 0;
        map[m + 1][j] = 0;
    }
    //上書き用島ナンバーの設定
    num = 2;
    //島ナンバーが1の島を探す
    for(i = 1;i < m + 1;i++) {
        for(j = 1;j < n + 1;j++) {
            if(map[i][j] == 1) {
                mapping(i,j);
                num++;
            }
        }
    }
    printf("%d\n",num - 2);
    //デバッグ用（マップの中身）
    /*for(i = 0;i < m + 2;i++) {
        for(j = 0;j < n + 2;j++) {
            printf("%2d ",map[i][j]);
        }
        printf("\n");
    }*/
    return 0;
}
//再帰を利用して隣り合っている島の数値を変更する
void mapping(int row,int col) {
    int i,j;
    map[row][col] = num;
    for(i = -1;i <= 1;i++) {
        for(j = -1;j <= 1;j++) {
            if(i == 0 || j == 0){
                if(map[row + i][col + j] == 1) {
                    mapping(row + i,col + j);
                }
            }
        }
    }
}
---------------------------------------------------
1000×1000の地図を使用するときにランタイムエラーが発生してしまうため再修正
