第一案
雪玉を大きいものから順に並べ、左を固定して、右から順番に比べていくことで規定の大きさを満たす一番小さな雪だるまの組み合わせを見つけていく。
------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
int main(void){
    int n,k,i,j,m,num;
    int cnt = 0; //直接値を入れない変数は初期化が必要
    int snow[100000];
    scanf("%d %d",&n,&k);
    for(i = 0;i < n;i++){
        scanf("%d",&snow[i]); //雪玉をテーブルに入れていく。ひとつの配列にひとつの数値として入れるため＆をつけてアドレスを指定することが必要
    }
    // 大きいものから並べるためのソート
    for(i = 0;i < n;i++){
        m = snow[i];
        for(j = i;j < n;j++){
            if(m < snow[j]){
                m = snow[j];
                num = j;
            }
        }
        if(snow[i] < m){
            snow[num] = snow[i];
            snow[i] = m;
        }
    }
    num = n - 1; //jは一番右から参照するため、個数-1の数字を入れておく
    // iとjが同じ雪玉を参照するまたはi < jになるまでループさせる
    for(i = 0;i < j - 1;i++){
        for(j = num;j > i;j--){
            if(snow[i] + snow[j] >= k){
                cnt++;
                num = j - 1; //snow[j]に入っているのは残っている中で一番大きい雪玉と組み合わせて規定値kを超えるサイズの雪玉であるため今後
                               それよりも小さい雪玉との組み合わせを試す必要がないため、次からはsnow[j]よりひとつ大きいものと組み合わせていく
                break; //最小の組み合わせが見つけられた時点でこれ以上比べてはいけないため、ループから脱出させる
            }
        }
    }
    
    printf("%d\n",cnt);
}
------------------------------------------------------------------------------------------------------------------------------------
無事100点
